The largest clique in a graph is a clique (a set of vertices where every vertex is connected to every other vertex) containing 
the maximum number of vertices possible in that graph, also known as the maximum clique or the clique number. Finding the maximum 
clique is a computationally difficult problem, classified as NP-complete, and algorithms like Bron-Kerbosch are used to find 
maximal cliques, from which the maximum clique can be identified. 

a. What is a clique?
A clique is a subgraph where every pair of distinct vertices is connected by an edge. 

b. What is the largest clique?
The largest clique is the clique with the most vertices. 

Key concepts:
a. Maximum Clique: A complete subgraph that has the largest number of vertices compared to any other clique in the graph. 
b. Maximal Clique: A clique that cannot be extended by adding another vertex from the graph and still remain a clique. 
c. Clique Number: The size (number of vertices) of a maximum clique in a given graph. 

Relationship between maximal and maximum cliques:
a. A maximum clique is always a maximal clique. 
b. However, a maximal clique is not necessarily a maximum clique. A graph can have many maximal cliques of different sizes, and only 
the largest among them is the maximum clique. 

Finding the largest clique:
a. The problem of finding the maximum clique is an NP-complete problem, meaning there is no known efficient algorithm for all cases. 
b. Algorithms exist to find the maximum clique, such as the Bron-Kerbosch algorithm for finding all maximal cliques, from which the 
maximum one can be determined. 
c. Wolfram MathWorld also describes how to find all maximum cliques using the Wolfram Language's FindClique function. 
--------------------------------------------------------------------------------------------------------------------------------------

Bitmasking is the right tool for the kind of ‚Äúcheck all subsets‚Äù problem.

üß† Step 1: What is a bitmask?
A bitmask is just an integer that represents a subset using its binary digits (bits).
Each bit position corresponds to an element (in this case, a parliament member).
Bit 1 ‚Üí member is included in the subset
Bit 0 ‚Üí member is not included

For example, if N = 5 (members 1‚Äì5):
Bitmask (binary)	Subset	Decimal value
00001	{1}	1
00010	{2}	2
00101	{1,3}	5
11100	{3,4,5}	28
11111	{1,2,3,4,5}	31

‚öôÔ∏è Step 2: How to iterate through all subsets

You can use a simple for loop:
for bit in range(1, 1 << N):   # 1 to 2^N - 1
    subset = []
    for i in range(N):
        if bit & (1 << i):     # if the i-th bit is ON
            subset.append(i + 1)  # members are 1-indexed

Excellent üëå ‚Äî visualization is the secret weapon for mastering bitmask problems.
Once you can see subsets in binary form, everything ‚Äî loops, masks, and logic ‚Äî becomes intuitive.

Let‚Äôs build that intuition step-by-step.
üß© Step 1: Represent subsets visually
Imagine you have N = 4 members: A, B, C, D
They correspond to bits (from right to left):

Bit position	3	2	1	0
Member name	  D	C	B	A

Now, each integer from 1 to 2‚Å¥ - 1 = 15 represents a subset:
Decimal	Binary	Subset
1	0001	{A}
2	0010	{B}
3	0011	{A, B}
4	0100	{C}
5	0101	{A, C}
6	0110	{B, C}
7	0111	{A, B, C}
8	1000	{D}
9	1001	{A, D}
15	1111	{A, B, C, D}

üß† Step 2: Think of bit as a pattern selector
Let‚Äôs take bit = 13.
In binary ‚Üí 1101.

Member	D	C	B	A
Bit	1	1	0	1
Include?	‚úÖ	‚úÖ	‚ùå	‚úÖ
‚Üí Subset = {A, C, D}

So when the loop runs:
for i in range(N):
    if bit & (1 << i):
        # This member is included
you‚Äôre literally scanning the binary digits of the number.

üéØ Step 3: How to debug subsets in your head
Let‚Äôs say bit = 5 ‚Üí binary 0101.
Rightmost bit (A): 1 ‚Üí include A
Next bit (B): 0 ‚Üí skip
Next (C): 1 ‚Üí include C
Next (D): 0 ‚Üí skip
‚Üí Subset = {A, C}
üëâ Trick: read binary from right to left (bit 0 = first element).

üßÆ Step 4: Understanding (1 << N) and (1 << i)
These are the most important shifts.
Expression	Meaning	Example
1 << N	gives 2‚Åø	If N=4 ‚Üí 16
(1 << i)	turns ON the i-th bit	If i=2 ‚Üí 0100

‚öôÔ∏è Step 5: Quick paper visualization technique
Draw this mini chart before starting coding:
i:    3  2  1  0
bit:  D  C  B  A
Now, when you see bit = 11 ‚Üí binary 1011
‚Üí Subset {A, B, D}
This table helps you read bits as subsets faster during contests.

üí° Step 6: Bitmask tips for contests
a. Loop range: for bit in range(1, 1 << N)
‚Üí iterates through all non-empty subsets

b. Count bits quickly:
bin(bit).count('1')
gives number of 1s = size of subset

c. Pre-check optimization:
If you only need subsets of size k, skip others:
if bin(bit).count('1') != k:
    continue

d. Subset iteration order:
Smallest subsets ‚Üí lower numbers
Largest subsets ‚Üí bigger numbers
Reverse iteration helps find largest valid one faster

üß† Step 7: Your mental model
When you see:
for bit in range(1, 1 << N):

Visualize this:
bit = 1  -> 0001 -> {A}
bit = 2  -> 0010 -> {B}
bit = 3  -> 0011 -> {A,B}
bit = 4  -> 0100 -> {C}
bit = 5  -> 0101 -> {A,C}
...
bit = 15 -> 1111 -> {A,B,C,D}

Every iteration = one possible subset = one test case for your logic.
