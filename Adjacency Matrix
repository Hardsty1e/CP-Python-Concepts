Adjacency Matrix Concept:
An adjacency matrix is a fundamental way to represent a graph (a set of vertices/nodes and edges/connections) in computer science.

Definition:
An adjacency matrix, denoted as A, for a graph with N vertices is an N×N square matrix where:
- The rows and columns correspond to the vertices (nodes) of the graph.
- The entry at A[i][j] indicates whether an edge (a connection) exists from vertex i to vertex j.

Types of Graphs:
The matrix values and symmetry depend on the type of graph:
1. Unweighted Graph (Binary Matrix):
A[i][j]=1 (or True) if there is an edge between i and j.
A[i][j]=0 (or False) otherwise.

2. Weighted Graph:
A[i][j] stores the weight (cost, distance, etc.) of the edge between i and j.
If no edge exists, the value is often 0 or ∞ (infinity).

3. Undirected Graph:
If the connection goes both ways (like a friendship), the matrix is symmetric: A[i][j]=A[j][i].

4. Directed Graph:
If the connection only goes one way (like a one-way street), the matrix is not necessarily symmetric: A[i][j] can be 1 while A[j][i] is 0.

Core Use Cases:
Adjacency matrices are highly useful for specific graph algorithms and data structures:
   
Use Case	             Description	                                                           Why Adjacency Matrix?
1. Checking Edge         Existence	Determining if two nodes are connected.	                       Very fast: Checking A[i][j] takes O(1) time.

2. Dense Graphs	         Graphs where the number of edges is close to the maximum possible (N2).   Space efficiency is comparable to other methods, but constant-time lookup is a major advantage.

3. Matrix Operations	 Finding paths or counting walks between nodes.	                           Powers of the matrix (Ak) can reveal the number of paths of length k.

4. Algorithms	         Used in algorithms like Floyd-Warshall for all-pairs shortest paths.	   The fixed structure and indexed lookup simplify the logic.

Code Breakdown:
know = [[False] * N for _ in range(N)]
for _ in range(M):
    x, y = map(int, input().split())
    know[x - 1][y - 1] = True
    know[y - 1][x - 1] = True

1. Matrix Initialization:
know = [[False] * N for _ in range(N)]
    Purpose: This line creates the N×N adjacency matrix named know.

    Mechanism:

        [False] * N: Creates a single list of length N, filled with False values. This represents one row (or N columns).

        for _ in range(N): Repeats the creation of this row N times, building the full N×N matrix.

    Initial State: Every entry know[i][j] is initially False, signifying that no one knows anyone until the input relationships are processed.

2. Processing Relationships (Edges):
for _ in range(M):
    x, y = map(int, input().split())
    know[x - 1][y - 1] = True
    know[y - 1][x - 1] = True
    Loop: The code iterates M times, once for each relationship (edge) provided in the input.

    Input and Indexing:

        x, y = map(int, input().split()): Reads two integers, x and y, representing the IDs of the two people who know each other.

        x−1 and y−1: This is a crucial step. Since person IDs are typically 1-indexed (e.g., people 1 through N), but Python lists are 0-indexed (indices 0 through N−1), we subtract 1 to get the correct matrix indices.

    Setting the Relationship (Undirected Edge):

        know[x - 1][y - 1] = True: Sets the entry for the edge from person x to person y to True.

        know[y - 1][x - 1] = True: Crucially, this sets the reverse entry from y to x to True. This makes the graph undirected (symmetric), meaning if x knows y, y must also know x.

The final know matrix is the complete adjacency matrix representing all the "knows" relationships in the group.
