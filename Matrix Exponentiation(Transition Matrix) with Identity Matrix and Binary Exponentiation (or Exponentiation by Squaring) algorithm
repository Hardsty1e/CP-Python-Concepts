The matrix exponentiation method (also known as the transition matrix method) is a powerful technique rooted in linear algebra for solving problems involving linear recurrence relations—like the Fibonacci or, in your case, the Tribonacci sequence—in logarithmic time complexity.

Main formulaes:
1. Vn+1(next state) = M(Transition/Generator Matrix).Vn(previous state)
2. Vn = M^ (n-k) . Vk 

The Mathematics Behind Matrix Exponentiation:
The goal is to compute the n-th term of a sequence defined by:
an​ = c1​an−1 ​+ c2​an−2​ +⋯+ ck​an−k​

We use linear algebra to transform this scalar recurrence into a vector-matrix equation.

1. Defining the State Vector and Transition
A linear recurrence relation depends on a fixed number (k) of previous terms. We define the State Vector (Vn​) as a column vector containing these k terms:
Vn​ = ​an, ​an−1​, ..., an−k+1
The key idea is that we can find the next state vector, Vn+1​, by multiplying the current state vector, Vn​, by a constant k×k matrix, M:
Vn+1 ​= M⋅Vn​
This matrix M is called the Transition Matrix or Generator Matrix.​​​

2. Constructing the Transition Matrix (M)
The matrix M is built to encode the recurrence relation into the matrix multiplication process.

A. The First Row (The Recurrence)
The first element of Vn+1​ is an+1​.
an+1 ​= c1​an ​+ c2​an−1 ​+⋯+ ck​an−k+1​

To generate this result through multiplication, the first row of M must contain the coefficients of the recurrence, c1​,c2​,…,ck​
e.g. M = [
        [1, 1],
        [1, 0]
    ]
for fibonacci sequence where a1 = 0 and a2 = 1

M = [
        [1, 1, 1],
        [1, 0, 0],
        [0, 1, 0]
    ]
for tribonacci sequence where a1 = 0, a2 = 0 and a3 = 1

That is an excellent question. The matrix exponentiation method (also known as the transition matrix method) is a powerful technique rooted in linear algebra for solving problems involving linear recurrence relations—like the Fibonacci or, in your case, the Tribonacci sequence—in logarithmic time complexity.

Here is a detailed mathematical explanation of the method.

The Mathematics Behind Matrix Exponentiation

The goal is to compute the n-th term of a sequence defined by:
an​=c1​an−1​+c2​an−2​+⋯+ck​an−k​

We use linear algebra to transform this scalar recurrence into a vector-matrix equation.

1. Defining the State Vector and Transition

A linear recurrence relation depends on a fixed number (k) of previous terms. We define the State Vector (Vn​) as a column vector containing these k terms:
Vn​=​an​an−1​⋮an−k+1​​​

The key idea is that we can find the next state vector, Vn+1​, by multiplying the current state vector, Vn​, by a constant k×k matrix, M:
Vn+1​=M⋅Vn​

This matrix M is called the Transition Matrix or Generator Matrix.

2. Constructing the Transition Matrix (M)

The matrix M is built to encode the recurrence relation into the matrix multiplication process.

A. The First Row (The Recurrence)

The first element of Vn+1​ is an+1​.
an+1​=c1​an​+c2​an−1​+⋯+ck​an−k+1​

To generate this result through multiplication, the first row of M must contain the coefficients of the recurrence, c1​,c2​,…,ck​:
(an+1​⋮​)=(c1​⋮​c2​⋮​…⋱​ck​⋮​)×​an​an−1​⋮an−k+1​​​

B. The Subsequent Rows (The Identity Shift)
All other rows in the state vector are just shifted versions of the previous state. For example:
* The second term in Vn+1​ is an​. This must be equal to the first term in Vn​.
* The third term in Vn+1​ is an−1​. This must be equal to the second term in Vn​.

This is achieved by using an Identity Matrix segment in the rest of M:
1. Row 2 of M is (1​0​0​…​)
2. Row 3 of M is (0​1​0​…​)
3. ... and so on.

The resulting matrix M looks like this :
M = [
        [c1, c2, c3, ..., ck],
        [1, 0, 0, ..., 0],
        [0, 1, 0, ..., 0]
        ....
        [0, 0, 0, ..., 1, 0]
    ]

3. The Logarithmic Speed
The real speedup comes from the matpow function, which uses the Exponentiation by Squaring algorithm.
If you calculate Mn by multiplying M by itself n times, the time complexity is O(n⋅k3).
By using binary exponentiation, you calculate Mn using only O(logn) matrix multiplications. Since each matrix multiplication takes O(k3) time (where k=3 is fixed here), the overall time complexity is drastically reduced to:
O(k3⋅logn)



Example Fibonnaci Code:
# This function uses matrix exponentiation method to calculate the nth term in fibonacci series

def matrix_multiplication(A, B):
    mod = 10007
    
    result = [[0]*2 for _ in range(2)]

    for i in range(2):
        for j in range(2):
            for k in range(2):
                result[i][j] = (result[i][j] + A[i][k]*B[k][j]) % mod

    return result

def matrix_exponentiation(M, power):    # Binary exponentiation algorithm
    result = [[1 if i == j else 0 for j in range(2)] for i in range(2)]    # Identity Matrix

    while power > 0:
        if power % 2 == 1:
            result = matrix_multiplication(result, M)
        M = matrix_multiplication(M, M)
        power //= 2
    return result

def fibonacci(n):
    if n == 1:
        return 0

    if n == 2:
        return 1

    M = [
        [1, 1],
        [1, 0]
    ]

    M_power = matrix_exponentiation(M, n-2)

    return M_power[0][0]

n = int(input())
print(fibonacci(n))
----------------------------------------------------------------------------------------------------------------

Example Tribonacci code:
def matmul(A, B):
    # 3x3 matrix multiplication mod 10007
    mod = 10007
    result = [[0]*3 for _ in range(3)]
    for i in range(3):
        for j in range(3):
            for k in range(3):
                result[i][j] = (result[i][j] + A[i][k]*B[k][j]) % mod
    return result

def matpow(M, power):
    # Fast exponentiation of matrix M^power
    result = [[1 if i == j else 0 for j in range(3)] for i in range(3)]  # Identity matrix
    while power > 0:
        if power % 2 == 1:
            result = matmul(result, M)
        M = matmul(M, M)
        power //= 2
    return result

def tribonacci_matrix(n):
    if n == 1 or n == 2:
        return 0
    if n == 3:
        return 1

    M = [
        [1, 1, 1],
        [1, 0, 0],
        [0, 1, 0]
    ]

    M_power = matpow(M, n - 3)
    # a3=1, a2=0, a1=0  → only need top row * [1,0,0]
    return M_power[0][0] % 10007

n = int(input())
print(tribonacci_matrix(n))
